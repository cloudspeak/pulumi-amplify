# Pulumi Amplify
![Code formatting badge](https://img.shields.io/github/workflow/status/cloudspeak/pulumi-amplify/code_formatting?label=code%20formatting "Code formatting badge")
![Code quality badge](https://img.shields.io/github/workflow/status/cloudspeak/pulumi-amplify/code_quality?label=code%20quality "Code quality badge")
![Coding style badge](https://img.shields.io/github/workflow/status/cloudspeak/pulumi-amplify/coding_style?label=coding%20style "Coding style badge")
![Unit tests badge](https://img.shields.io/github/workflow/status/cloudspeak/pulumi-amplify/unit_tests?label=unit%20tests "Unit tests badge")

This package provides a Pulumi resource called `AmplifyGraphQLAPI` which deploys an AppSync API and associated DynamoDB tables based on an AWS Amplify project.  It gains the benefits of Amplify's frontend and backend code generation, but allows the resulting cloud resources to be managed by Pulumi rather than CloudFormation.

In a nutshell, it works like this:
* Create an Amplify project and add a GraphQL API, but do not push any resources to the cloud
* Create a Pulumi program which instantiates an `AmplifyGraphQLAPI` with the name of your Amplify API
* Deploy the Pulumi program, which will use code generated by Amplify to define the AppSync API and resolvers
* Every time you update your schema, tell Amplify to regenerate its code and then redeploy the Pulumi program

There is an example project in the `example` directory which can be used as a starting point.
Or, follow the instructions below to start a new project.


## Starting a new project with `pulumi-amplify`

1. **Create a [Pulumi AWS project](https://www.pulumi.com/docs/get-started/aws/)**.  We perform this step first because Pulumi causes problems if it is not initialized in a empty directory.

For example:

```
mkdir my_project && cd my_project
pulumi new aws-python
```

2. If you haven't already, you should **[install and configure AWS Amplify](https://docs.amplify.aws/start/getting-started/installation/q/integration/react#option-2-follow-the-instructions)**.

3. When you are ready, you can **initialize a new Amplify project**:

```
amplify init
```

> *Note:*  this will create an Amplify app and a deployment bucket in your AWS account. These are unused by `pulumi-amplify` but Amplify will not perform code generation if they do
not exist.

4. **Add a GraphQL API** to the project:

```
amplify add api
```

You must choose "GraphQL" and "Amazon Cognito User Pool" for authentication.  Make a note of the name you give your API, as you will need it later.  You must also enter your schema at this point, although it can be updated later.  **Do not run `amplify push`**, as this will deploy resources using CloudFormation in addition to the Pulumi-managed resources.

> *Note:* any additional Cognito settings you choose, such as the method of login, are **ignored** by `pulumi-amplify`, since we will define our own Cognito User Pool later in the process.

5. **Add client code generation** to the project, choosing the options which best fit your client application:

```
amplify add codegen
```

6. **Install the `pulumi-amplify` package** with `pip`.  For example, to install from a local directory, use the following:

```
pip install -e /path/to/pulumi-amplify
```

7. **Write your Pulumi program**.  You will need to create an `AmplifyGraphQLAPI` resource, which requires a Cognito User Pool and client, the name of your Amplify API, and the names of the GraphQL types which you want to create resolvers for.

For example, suppose you created an API called `notespulumi` with the following schema:

```graphql
type Note @model @auth(rules: [{allow: owner, operations: [create, update, delete]}]){
  id: ID!
  note: String!
}
```

Then your Pulumi program might look like this:

```python
import pulumi
from pulumi_amplify import AmplifyGraphQLAPI
from pulumi_aws import cognito

user_pool = cognito.UserPool("NotesUserPool")

user_pool_client = cognito.UserPoolClient(
    "NotesUserPoolClient", user_pool_id=user_pool.id
)

graphql_api = AmplifyGraphQLAPI(
    "NotesAmplifyGraphQLAPI",
    amplify_api_name="notespulumi",
    graphql_types=["Note"],
    user_pool=user_pool,
    user_pool_client=user_pool_client,
    client_source_path="src",
)
```

8. **Deploy your Pulumi stack**:

```
pulumi up
```

This will create an AppSync API with the Amplify-generated schema.  It will then use the resolvers generated by Amplify to create Dynamo tables and AppSync resolvers for each operation on the API.

8. You can now **write your frontend application** using the Amplify JavaScript library.  See the [Amplify documentation](https://docs.amplify.aws/start) for more information, where you can ignore anything related to backend deployment.  You will see that `pulumi-amplify` generates an `aws-exports.js` file in the source directory just like Amplify does, which contains all the necessary configuration for your frontend to communicate with the API.

### Updating the schema

The GraphQL schema is located in `amplify/backend/api/[apiname]/schema.graphql`.  If
you change the schema, you will need to use Amplify to regenerate the backend resolvers
and (optionally) the frontend request models:

* **Rebuild the backend schema and resolvers**:

```
amplify api gql-compile
```

* **Push the new backend configuration to AppSync**:

```
pulumi up
```

* **Rebuild the frontend request models** into `src/graphql` (if you are using them):

```
amplify codegen
```

# Known Issues and Limitations

* Amplify creates an Amplify app and deployment bucket which serve no purpose
* The Pulumi program assumes a DynamoDB backend
* The Pulumi program assumes Cognito for authentication, but ignored any further Cognito settings
* The Dynamo tables are assumed to require only a single hash key called `id` each
* Custom resolvers are currently untested



# Development

## Getting started

You need Python 3 (preferably 3.8) installed to start working on this project.

In order to install your virtualenv, just go to the root of the project and:
```bash
make install
```

## IDE

Nuage recommends [Visual Studio Code](https://code.visualstudio.com/download) to work on this project, and some default settings have been configured in the [.vscode/settings.json](.vscode/settings.json).

These settings merely enforce the code-quality guidelines defined below, but if you use another IDE it's probably worth taking a quick look at it to ensure compliance with the standard.

By default, we recommend:
1. Putting your virtualenv in a `venv` folder at the project root
2. Using a `.env` file to define your environment variables (cf. [python-dotenv](https://pypi.org/project/python-dotenv/))

## Unit tests

To run the unit tests, use the following command:

```
python setup.py test
```

## Code quality

This project has opinionated code-quality requirements:
- Code formatter: [black](https://black.readthedocs.io/en/stable/)
- Code linter: [pylint](https://www.pylint.org)
- Code style guidelines: [flake8](https://flake8.pycqa.org/en/latest/)

All of these tools are enforced at the commit-level via [pre-commit](https://pre-commit.com)

You can run the following command to apply code-quality to your project at any point:
```bash
make quality
```

Code quality configuration files:
- IDE-agnostic coding style settings are set in the [.editorconfig](.editorconfig) file
- Python-related settings are set in the [setup.cfg](setup.cfg) file
- Pre-commit-related settings are set in the [.pre-commit-config.yaml](.pre-commit-config.yaml) file

## Folder structure

```
.
├── .github/                                The Github Actions workflows
├── example/                                An example program which uses this provider package
├── pulumi_amplify/                         The main package folder
├── Makefile
├── README.md
├── requirements_dev.txt
├── setup.cfg
└── setup.py
```
